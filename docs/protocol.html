<title>protocol spec - micro:net</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1"><link rel="stylesheet" href="style.css"><script src="script.js"></script><div id="banner"></div><header><h1><a href="index.html">micro:net</a></h1><p>the new internet, powered by the BBC micro:bit</p><nav><a href="index.html">home</a> <a href="getstarted.html">get started</a> <a href="protocol.html" class="selected">protocol spec</a></nav></header><main><h2>V1 protocol spec</h2><p>This page intends to provide enough information surrounding the micro:net protocol for you to be able to implement a compatible micro:net client or server yourself.</p><h3>glossary of key terms</h3><dl><dt>Conversation</dt><dd>A series of back-and-forth messages between two micro:bits.</dd><dt>Domain</dt><dd>A string value uniquely identify an endpoint. This value is configurable and is hashed to an ID.</dd><dt>Endpoint</dt><dd>A micro:bit that has access to the micro:net and can send and receive messages through the micro:net.</dd><dt>ID</dt><dd>A 16-bit value to uniquely identify an endpoint. This value is configurable and is a bit like an IP address.</dd><dt>Message</dt><dd>A sequence of bytes sent over the micro:bit's radio module to another micro:bit.</dd><dt>micro:bit</dt><dd>That small (and exceptionally cool) computing device the BBC released back in 2016.<br><em>(All lowercase, so not capitalised when at the start of a sentence)</em></dd><dt>micro:net</dt><dd>The micro:bit-based mesh network that ambitiously intends to be the successor to the internet, and whose protocol is described herein.<br><em>(All lowercase, so not capitalised when at the start of a sentence)</em></dd><dt>Modem</dt><dd>An endpoint micro:bit that is running the modem software. This software bridges serial and radio communications. It can act as both a client and server, or just a client.</dd><dt>Modem daemon</dt><dd>Software that runs on a conventional computer that communicats with the modem on behalf of web browsers and other software that make requests.</dd><dt>PAC script</dt><dd>A script that automatically configures a web browser or operating system's proxy settings. micro:net uses a PAC script to proxy requests from the .micronet TLD through the modem daemon.</dd><dt>Radio</dt><dd>The micro:bit's <a href="https://tech.microbit.org/hardware/#low-level-radio-communications" target="_blank">2.4 GHz radio communications system</a>.</dd><dt>TLD</dt><dd>Top-level domain. For access to the micro:net, the TLD of .micronet is provided.</dd></dl><h3>identification</h3><p>Endpoints are uniquely identifiable by either their ID or domain. At a low level, the protocol's messages exclusively use the 16-bit ID for identification, but domains are used as a more human-friendly way of identifying and requesting data from endpoints. When in the browser, a user types in a domain suffixed with the .micronet TLD, and the domain gets converted to an ID.</p><p>Domains are resolved into their IDs through hashing so that the respective ID can be sent in messages. The domains are hashed into IDs using the following algorithm:</p><pre>function domainToId(domain) {
    var hashValue = 0xF758;

    for (var i = 0; i &lt; domain.length; i++) {
        hashValue += domain.charCodeAt(i) * ((((i + 3) % 100) ** 2) + 1);
    }

    return hashValue % 0x1_0000;
}</pre><blockquote><p><strong>non-normative</strong></p><p>The initial hash value of <code>0xF758</code> was chosen to make the <code>bbc</code> domain hash to the ID of <code>0x0BBC</code>.</p></blockquote><h3>message header</h3><p>In summary, the format of a message is <code>6D 6E 01 &lt;U8 command&gt; &lt;U8[] commandData&gt;</code>.</p><p>All messages start with <code>6D 6E 01</code>, which are the letters <code>mn</code> followed by the version number. After this header, we then supply a message command as a byte, followed by the command data — typically the sender's and receiver's IDs and other data as specified in the command listings in the next section.</p><h3>commands</h3><h4><code>0x10</code>: create new request conversation</h4><p>Command data: <code>&lt;U16 senderId&gt; &lt;U16 receiverId&gt; &lt;U16 conversationId&gt; &lt;U16 size&gt; &lt;U16 packetCount&gt;</code></p><p>Sent from the endpoint with sender ID <code>senderId</code> when it wants to create a new request conversation to <code>receiverId</code>.</p><p>The sending endpoint must generate a unique (typically randomised) <code>conversationId</code>.</p><p>The sending endpoint must know the size of the request data in advance. The size — in bytes — must be provided in <code>size</code>, and the <code>packetCount</code> as <code>Math.floor(size / 128)</code>.</p><h4><code>0x11</code>: ready to receive packet</h4><p>Command data: <code>&lt;U16 senderId&gt; &lt;U16 receiverId&gt; &lt;U16 conversationId&gt; &lt;U16 packetIndex&gt;</code></p><p>Sent from the endpoint with sender ID <code>senderId</code> when it is ready to receive a request or response packet with packet index <code>packetIndex</code> from <code>receiverId</code> for conversation <code>conversationId</code>.</p><p>This command is sent in response to <strong><code>0x10</code> create new request conversation</strong> or <strong><code>0x13</code> acknowledge request received; request to send response</strong>.</p><h4><code>0x12</code>: send packet</h4><p>Command data: <code>&lt;U16 senderId&gt; &lt;U16 receiverId&gt; &lt;U16 conversationId&gt; &lt;U16 packetIndex&gt; &lt;U8[] payload&gt; &lt;U8 checksum&gt;</code></p><p>Sent from the endpoint with sender ID <code>senderId</code> in reply to a <strong><code>0x11</code> ready to receive packet</strong> message from <code>receiverId</code> for conversation <code>conversationId</code> and packet index <code>packetIndex</code>.</p><p>Packet payload data (<code>payload</code>) must be a maximum of 128 bytes in size.</p><p>The byte index of the data being requested can be found by multiplying the <code>packetIndex</code> by 128.</p><p>Following the <code>payload</code>, the <code>checksum</code> must be found using the following algorithm:</p><pre>function calculateChecksum(packetIndex, payload) {
    var checksum = packetIndex * 3;

    for (var i = 0; i &lt; payload.length; i++) {
        checksum += payload[i] * ((((i + 3) % 100) ** 2) + 1);
    }

    return checksum &amp; 0xFF;
}</pre><h4><code>0x13</code>: acknowledge request received; request to send response</h4><p>Command data: <code>&lt;U16 senderId&gt; &lt;U16 receiverId&gt; &lt;U16 conversationId&gt; &lt;U16 size&gt; &lt;U16 packetCount&gt;</code></p><p>Sent from the endpoint with sender ID <code>senderId</code> when it has successfully received all packets pertaining to the request from <code>receiverId</code> for conversation <code>conversationId</code>, and is ready to send the response.</p><p>The sending endpoint must know the size of the response data in advance. The size — in bytes — must be provided in <code>size</code>, and the <code>packetCount</code> as <code>Math.floor(size / 128)</code>.</p><h4><code>0x14</code>: acknowledge response received</h4><p>Command data: <code>&lt;U16 senderId&gt; &lt;U16 receiverId&gt; &lt;U16 conversationId&gt;</code></p><p>Sent from the endpoint with sender ID <code>senderId</code> when it has successfully received all packets pertaining to the response from <code>receiverId</code> for conversation <code>conversationId</code>.</p><h4><code>0x15</code>: respond to acknowledgement for response reception</h4><p>Command data: <code>&lt;U16 senderId&gt; &lt;U16 receiverId&gt; &lt;U16 conversationId&gt;</code></p><p>Sent from the endpoint with sender ID <code>senderId</code> in reply to a <strong><code>0x14</code> acknowledge response received</strong> command from <code>receiverId</code> for conversation <code>conversationId</code>.</p><h4><code>0x40</code>: error</h4><p><em>The implementation of both or either the emitter or handler for this command is optional.</em></p><p>Command data: <code>&lt;U16 senderId&gt; &lt;U16 receiverId&gt; &lt;U8 errorType&gt;</code></p><p>Sent from the endpoint with sender ID <code>senderId</code> when the endpoint is unable to process a prior message from <code>receiverId</code>.</p><p>The <code>errorType</code> may be one of the following values:</p><table><tr><th>Value</th><th>Meaning</th></tr><tr><td><code>0x00</code></td><td><strong>Other/unknown</strong></td></tr><tr><td><code>0x10</code></td><td><strong>Unknown conversation</strong><br>The received <code>conversationId</code> does not reference an existing open conversation.</td></tr><tr><td><code>0x11</code></td><td><strong>Unknown packet</strong><br>The requested <code>packetIndex</code> is out of bounds.</td></tr><tr><td><code>0x12</code></td><td><strong>Invalid state</strong><br>Either the sender wants to receive request packets after it has acknowledged that the request has been fully received; or the sender wants to receive response packets when the receiver has not fully received the request packets yet.</td></tr></table><blockquote><p><strong>non-normative</strong></p><h3>example HTTP request and response</h3><ol><li><code>0xAAAA</code> creates a new request conversation (ID <code>0x1234</code>) to <code>0x0BBC</code> of size <code>0x00CB</code> (203 bytes) as 2 packets<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (create new request conversation)">10</abbr> <abbr title="Sender ID">AA AA</abbr> <abbr title="Receiver ID">0B BC</abbr> <abbr title="Conversation ID">12 34</abbr> <abbr title="Request size">00 CB</abbr> <abbr title="Packet count">00 02</abbr></pre></li><li><code>0x0BBC</code> requests from <code>0xAAAA</code> packet 1 (index <code>0x0000</code>) of 2 for request part<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (ready to receive packet)">11</abbr> <abbr title="Sender ID">0B BC</abbr> <abbr title="Receiver ID">AA AA</abbr> <abbr title="Conversation ID">12 34</abbr> <abbr title="Packet index">00 00</abbr></pre></li><li><code>0xAAAA</code> sends to <code>0x0BBC</code> packet 1<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (send packet)">12</abbr> <abbr title="Sender ID">AA AA</abbr> <abbr title="Receiver ID">0B BC</abbr> <abbr title="Conversation ID">12 34</abbr> <abbr title="Packet index">00 00</abbr> [then 128 bytes of HTTP request data] [checksum byte]</pre></li><li><code>0x0BBC</code> requests from <code>0xAAAA</code> packet 2 (index <code>0x0001</code>) of 2 for request part<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (ready to receive packet)">11</abbr> <abbr title="Sender ID">0B BC</abbr> <abbr title="Receiver ID">AA AA</abbr> <abbr title="Conversation ID">12 34</abbr> <abbr title="Packet index">00 01</abbr></pre></li><li><code>0xAAAA</code> sends to <code>0x0BBC</code> packet 2<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (send packet)">12</abbr> <abbr title="Sender ID">AA AA</abbr> <abbr title="Receiver ID">0B BC</abbr> <abbr title="Conversation ID">12 34</abbr> <abbr title="Packet index">00 01</abbr> [then 75 bytes of HTTP request data] [checksum byte]</pre></li><li><code>0x0BBC</code> acknowledges to <code>0xAAAA</code> that it has received the request, and requests to send a response of size <code>0x0085</code> (133 bytes) as 2 packets<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (acknowledge request received; request to send response)">13</abbr> <abbr title="Sender ID">0B BC</abbr> <abbr title="Receiver ID">AA AA</abbr> <abbr title="Conversation ID">12 34</abbr> <abbr title="Response size">00 85</abbr> <abbr title="Packet count">00 02</abbr></pre></li><li><code>0xAAAA</code> requests from <code>0x0BBC</code> packet 1 (index <code>0x0000</code>) of 2 for response part<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (ready to receive packet)">11</abbr> <abbr title="Sender ID">AA AA</abbr> <abbr title="Receiver ID">0B BC</abbr> <abbr title="Conversation ID">12 34</abbr> <abbr title="Packet index">00 00</abbr></pre></li><li><code>0x0BBC</code> sends to <code>0xAAAA</code> packet 1<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (send packet)">12</abbr> <abbr title="Sender ID">0B BC</abbr> <abbr title="Receiver ID">AA AA</abbr> <abbr title="Conversation ID">12 34</abbr> <abbr title="Packet index">00 00</abbr> [then 128 bytes of HTTP response data] [checksum byte]</pre></li><li><code>0xAAAA</code> requests from <code>0x0BBC</code> packet 2 (index <code>0x0001</code>) of 2 for response part<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (ready to receive packet)">11</abbr> <abbr title="Sender ID">AA AA</abbr> <abbr title="Receiver ID">0B BC</abbr> <abbr title="Conversation ID">12 34</abbr> <abbr title="Packet index">00 01</abbr></pre></li><li><code>0x0BBC</code> sends to <code>0xAAAA</code> packet 2<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (send packet)">12</abbr> <abbr title="Sender ID">0B BC</abbr> <abbr title="Receiver ID">AA AA</abbr> <abbr title="Conversation ID">12 34</abbr> <abbr title="Packet index">00 01</abbr> [then 5 bytes of HTTP response data] [checksum byte]</pre></li><li><code>0xAAAA</code> acknowledges to <code>0x0BBC</code> that it has received the response<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (acknowledge response received)">14</abbr> <abbr title="Sender ID">AA AA</abbr> <abbr title="Receiver ID">0B BC</abbr> <abbr title="Conversation ID">12 34</abbr></pre></li><li><code>0x0BBC</code> confirms to <code>0xAAAA</code> that conversation <code>0x1234</code> is now closed<br><pre><abbr title="micro:net header">6D 6E 01</abbr> <abbr title="Command (respond to acknowledgement for response reception)">15</abbr> <abbr title="Sender ID">0B BC</abbr> <abbr title="Receiver ID">AA AA</abbr> <abbr title="Conversation ID">12 34</abbr></pre></li></ol></blockquote></main><footer><p>&copy; 2024 James Livesey/BBC. While made by a few BBC employees, micro:net is not an official project of the BBC.</p></footer>